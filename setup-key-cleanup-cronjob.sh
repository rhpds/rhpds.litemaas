#!/bin/bash
# =============================================================================
# LiteMaaS Key Cleanup Cronjob Setup
# =============================================================================
# Creates a cronjob on bastion that runs daily to delete old virtual API keys
#
# Usage:
#   ./setup-key-cleanup-cronjob.sh <namespace>
#
# Examples:
#   ./setup-key-cleanup-cronjob.sh litemaas
#   ./setup-key-cleanup-cronjob.sh litellm-rhpds
#
# What it does:
#   1. Creates a script on bastion at /usr/local/bin/cleanup-litemaas-keys-<namespace>.sh
#   2. Sets up a daily cronjob (runs at 2 AM) to execute the cleanup
#   3. The cronjob auto-discovers LiteLLM URL and master key from OpenShift
#   4. Deletes keys matching EITHER condition:
#      - Expired keys (expires field < current time)
#      - Old keys (created_at > 30 days ago)
# =============================================================================

set -e

NAMESPACE="${1}"

if [ -z "$NAMESPACE" ]; then
    echo "Usage: $0 <namespace>"
    echo ""
    echo "Example:"
    echo "  $0 litemaas"
    exit 1
fi

echo "========================================="
echo "LiteMaaS Key Cleanup Cronjob Setup"
echo "========================================="
echo "Namespace: $NAMESPACE"
echo ""

# Detect if we're running on bastion
if [[ "$(hostname)" == *"bastion"* ]] || [[ "$(hostname)" == *"utility"* ]]; then
    ON_BASTION=true
    echo "Detected: Running on bastion/utility node"
else
    ON_BASTION=false
    echo "Detected: Running from workstation (will use SSH)"
fi
echo ""

# Check if oc is available
if ! command -v oc &> /dev/null; then
    echo "ERROR: oc command not found. Please install OpenShift CLI."
    exit 1
fi

# Check if logged in
if ! oc whoami &> /dev/null; then
    echo "ERROR: Not logged into OpenShift. Run 'oc login' first."
    exit 1
fi

# Verify namespace exists
if ! oc get namespace "$NAMESPACE" &> /dev/null; then
    echo "ERROR: Namespace '$NAMESPACE' does not exist."
    exit 1
fi

echo "Creating cleanup script on bastion..."

# Create the cleanup script that will be installed on bastion
CLEANUP_SCRIPT_CONTENT='#!/bin/bash
# Auto-generated by setup-key-cleanup-cronjob.sh
# DO NOT EDIT MANUALLY - use setup script to regenerate

NAMESPACE="'"$NAMESPACE"'"
DAYS_OLD=30
LOGFILE="/var/log/litemaas-key-cleanup.log"

# Redirect all output to logfile
exec >> "$LOGFILE" 2>&1

echo "========================================="
echo "LiteMaaS Key Cleanup - $(date)"
echo "========================================="
echo "Namespace: $NAMESPACE"
echo "Cleanup Policy:"
echo "  - Delete expired keys (expires < current time)"
echo "  - Delete keys older than $DAYS_OLD days"
echo ""

# Get LiteLLM URL - find route targeting litellm service
echo "Getting LiteLLM URL..."
LITELLM_ROUTE=$(oc get routes -n "$NAMESPACE" -o json 2>/dev/null | \
                jq -r '\''.items[] | select(.spec.to.name == "litellm") | .spec.host'\'' 2>/dev/null | head -1)

if [ -z "$LITELLM_ROUTE" ]; then
    LITELLM_ROUTE=$(oc get routes -n "$NAMESPACE" -o json 2>/dev/null | \
                    jq -r '\''.items[] | select(.spec.to.name | test("litellm|litemaas")) | select(.spec.to.name | test("backend|frontend") | not) | .spec.host'\'' 2>/dev/null | head -1)
fi

if [ -z "$LITELLM_ROUTE" ]; then
    echo "ERROR: LiteLLM API route not found in namespace '\''$NAMESPACE'\''"
    exit 1
fi
LITELLM_URL="https://$LITELLM_ROUTE"
echo "  LiteLLM URL: $LITELLM_URL"

# Get LiteLLM Master Key
echo "Getting LiteLLM Master Key..."
LITELLM_SECRET_NAME=$(oc get secrets -n "$NAMESPACE" -o json 2>/dev/null | \
                      jq -r '\''.items[] | select(.data.LITELLM_MASTER_KEY != null) | .metadata.name'\'' 2>/dev/null | head -1)

if [ -z "$LITELLM_SECRET_NAME" ]; then
    echo "ERROR: Secret with LITELLM_MASTER_KEY not found in namespace '\''$NAMESPACE'\''"
    exit 1
fi

LITELLM_MASTER_KEY=$(oc get secret "$LITELLM_SECRET_NAME" -n "$NAMESPACE" -o jsonpath='\''{.data.LITELLM_MASTER_KEY}'\'' | base64 -d)
echo "  Master Key: ${LITELLM_MASTER_KEY:0:10}..."
echo ""

# Get all keys from LiteLLM API (with pagination)
echo "Fetching all virtual keys from LiteLLM..."

ALL_KEYS="[]"
PAGE=1
PAGE_SIZE=100

while true; do
    echo "  Fetching page $PAGE..."
    RESPONSE=$(curl -s -X GET "$LITELLM_URL/key/list?return_full_object=true&size=$PAGE_SIZE&page=$PAGE" \
      -H "Authorization: Bearer $LITELLM_MASTER_KEY" \
      -H "Content-Type: application/json")

    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to fetch keys from LiteLLM API"
        exit 1
    fi

    # Check if response is valid
    if ! echo "$RESPONSE" | jq -e '\''.keys'\'' &> /dev/null; then
        echo "ERROR: Invalid response from LiteLLM API"
        echo "Response: $RESPONSE"
        exit 1
    fi

    # Append keys from this page
    ALL_KEYS=$(echo "$ALL_KEYS" | jq --argjson page "$(echo "$RESPONSE" | jq '\''.keys'\'')" '\''. + $page'\'')

    # Check if there are more pages
    TOTAL_PAGES=$(echo "$RESPONSE" | jq -r '\''.total_pages'\'')
    if [ "$PAGE" -ge "$TOTAL_PAGES" ]; then
        break
    fi
    PAGE=$((PAGE + 1))
done

RESPONSE=$(jq -n --argjson keys "$ALL_KEYS" '\''{"keys": $keys}'\'')

echo "  Total keys fetched: $(echo "$ALL_KEYS" | jq '\''length'\'')"
echo ""

# Get current time as Unix timestamp
CURRENT_TIMESTAMP=$(date -u +%s)
CURRENT_DATE=$(date -u '\''+%Y-%m-%d %H:%M:%S'\'')

# Calculate cutoff timestamp (30 days ago)
CUTOFF_TIMESTAMP=$(date -u -d "$DAYS_OLD days ago" +%s 2>/dev/null || date -u -v-${DAYS_OLD}d +%s)
CUTOFF_DATE=$(date -u -d "@$CUTOFF_TIMESTAMP" '\''+%Y-%m-%d %H:%M:%S'\'' 2>/dev/null || date -u -r "$CUTOFF_TIMESTAMP" '\''+%Y-%m-%d %H:%M:%S'\'')

echo "  Current time: $CURRENT_DATE (Unix: $CURRENT_TIMESTAMP)"
echo "  Cutoff date (30d ago): $CUTOFF_DATE (Unix: $CUTOFF_TIMESTAMP)"
echo ""

# Extract keys to delete (expired OR older than 30 days)
# Convert ISO 8601 to Unix timestamps for numeric comparison
KEYS_TO_DELETE=$(echo "$RESPONSE" | jq -r --arg now "$CURRENT_TIMESTAMP" --arg cutoff "$CUTOFF_TIMESTAMP" '\''
  .keys[] |
  select(
    # Check if expired (expires timestamp < current timestamp)
    ((.expires != null) and ((.expires | fromdateiso8601) < ($now | tonumber))) or
    # Check if older than 30 days (calculate created_at from expires - duration)
    (
      (.expires != null) and
      (.metadata.duration != null) and
      (
        # Parse duration (e.g., "7d", "30d") and calculate created_at
        (.metadata.duration |
          if endswith("d") then
            (.[:-1] | tonumber) * 86400
          elif endswith("h") then
            (.[:-1] | tonumber) * 3600
          else
            0
          end
        ) as $duration_seconds |
        # created_at = expires - duration (both as Unix timestamps)
        ((.expires | fromdateiso8601) - $duration_seconds) < ($cutoff | tonumber)
      )
    )
  ) |
  .token
'\'' 2>/dev/null)

# Count keys by reason
TOTAL_KEYS=$(echo "$RESPONSE" | jq -r '\''.keys | length | . // 0'\'' 2>/dev/null)
EXPIRED_KEYS=$(echo "$RESPONSE" | jq -r --arg now "$CURRENT_TIMESTAMP" '\''
  ([.keys[] | select((.expires != null) and ((.expires | fromdateiso8601) < ($now | tonumber)))] | length) // 0
'\'' 2>/dev/null)
OLD_KEYS=$(echo "$RESPONSE" | jq -r --arg cutoff "$CUTOFF_TIMESTAMP" '\''
  ([.keys[] |
   select(
     (.expires != null) and
     (.metadata.duration != null) and
     (
       (.metadata.duration |
         if endswith("d") then
           (.[:-1] | tonumber) * 86400
         elif endswith("h") then
           (.[:-1] | tonumber) * 3600
         else
           0
         end
       ) as $duration_seconds |
       ((.expires | fromdateiso8601) - $duration_seconds) < ($cutoff | tonumber)
     )
   )
  ] | length) // 0
'\'' 2>/dev/null)
TOTAL_TO_DELETE=$(echo "$KEYS_TO_DELETE" | grep -v '\''^$'\'' | wc -l | tr -d '\'' '\'')

echo "Key Statistics:"
echo "  Total keys in system: $TOTAL_KEYS"
echo "  Expired keys: $EXPIRED_KEYS"
echo "  Keys older than $DAYS_OLD days: $OLD_KEYS"
echo "  Total to delete: $TOTAL_TO_DELETE"
echo ""

if [ "$TOTAL_TO_DELETE" -eq 0 ]; then
    echo "No keys to delete."
    exit 0
fi

echo "Keys to delete:"
echo "$RESPONSE" | jq -r --arg now "$CURRENT_TIMESTAMP" --arg cutoff "$CUTOFF_TIMESTAMP" '\''
  .keys[] |
  select(
    ((.expires != null) and ((.expires | fromdateiso8601) < ($now | tonumber))) or
    (
      (.expires != null) and
      (.metadata.duration != null) and
      (
        (.metadata.duration |
          if endswith("d") then
            (.[:-1] | tonumber) * 86400
          elif endswith("h") then
            (.[:-1] | tonumber) * 3600
          else
            0
          end
        ) as $duration_seconds |
        ((.expires | fromdateiso8601) - $duration_seconds) < ($cutoff | tonumber)
      )
    )
  ) |
  if (.expires != null) and ((.expires | fromdateiso8601) < ($now | tonumber)) then
    "  - Token: \(.token[:20])... | Alias: \(.key_alias // "N/A") | EXPIRED: \(.expires)"
  else
    (
      (.metadata.duration |
        if endswith("d") then
          (.[:-1] | tonumber) * 86400
        elif endswith("h") then
          (.[:-1] | tonumber) * 3600
        else
          0
        end
      ) as $duration_seconds |
      "  - Token: \(.token[:20])... | Alias: \(.key_alias // "N/A") | OLD: Created \(((.expires | fromdateiso8601) - $duration_seconds | todateiso8601))"
    )
  end
'\'' 2>/dev/null

echo ""
echo "Deleting keys (expired and old)..."

# Delete each key
DELETED_COUNT=0
FAILED_COUNT=0

while IFS= read -r key_token; do
    if [ -n "$key_token" ]; then
        echo -n "  Deleting key ${key_token:0:20}... "

        DELETE_RESPONSE=$(curl -s -X POST "$LITELLM_URL/key/delete" \
          -H "Authorization: Bearer $LITELLM_MASTER_KEY" \
          -H "Content-Type: application/json" \
          -d "{\"keys\": [\"$key_token\"]}")

        if echo "$DELETE_RESPONSE" | jq -e '\''.deleted_keys'\'' &> /dev/null; then
            echo "✓ Deleted"
            DELETED_COUNT=$((DELETED_COUNT + 1))
        else
            echo "✗ Failed"
            echo "    Response: $DELETE_RESPONSE"
            FAILED_COUNT=$((FAILED_COUNT + 1))
        fi
    fi
done <<< "$KEYS_TO_DELETE"

echo ""
echo "========================================="
echo "Cleanup Complete - $(date)"
echo "========================================="
echo "Successfully deleted: $DELETED_COUNT keys"
if [ "$FAILED_COUNT" -gt 0 ]; then
    echo "Failed to delete: $FAILED_COUNT keys"
fi
echo ""
'

# Write the script to bastion
echo "Installing script to /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh..."

if [ "$ON_BASTION" = true ]; then
    # Running on bastion - write directly
    echo "$CLEANUP_SCRIPT_CONTENT" | sudo tee /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh > /dev/null
    sudo chmod +x /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh
else
    # Running from workstation - use SSH
    echo "$CLEANUP_SCRIPT_CONTENT" | ssh bastion "sudo tee /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh > /dev/null"
    ssh bastion "sudo chmod +x /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh"
fi

echo "✓ Script installed"
echo ""

# Create cronjob entry (runs daily at 2 AM)
echo "Setting up cronjob (runs daily at 2 AM)..."

CRON_ENTRY="0 2 * * * /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh"

if [ "$ON_BASTION" = true ]; then
    # Running on bastion - manage crontab directly
    if sudo crontab -l 2>/dev/null | grep -q "cleanup-litemaas-keys-${NAMESPACE}.sh"; then
        echo "Cronjob already exists. Updating..."
        sudo crontab -l 2>/dev/null | grep -v "cleanup-litemaas-keys-${NAMESPACE}.sh" | sudo crontab -
    fi
    (sudo crontab -l 2>/dev/null; echo "$CRON_ENTRY") | sudo crontab -
else
    # Running from workstation - use SSH
    if ssh bastion "sudo crontab -l 2>/dev/null | grep -q 'cleanup-litemaas-keys-${NAMESPACE}.sh'"; then
        echo "Cronjob already exists. Updating..."
        ssh bastion "sudo crontab -l 2>/dev/null | grep -v 'cleanup-litemaas-keys-${NAMESPACE}.sh' | sudo crontab -"
    fi
    ssh bastion "(sudo crontab -l 2>/dev/null; echo '$CRON_ENTRY') | sudo crontab -"
fi

echo "✓ Cronjob created"
echo ""

# Create logrotate config to prevent log file from growing too large
echo "Setting up log rotation..."

LOGROTATE_CONFIG="/etc/logrotate.d/litemaas-key-cleanup-${NAMESPACE}"

if [ "$ON_BASTION" = true ]; then
    # Running on bastion - write directly
    sudo tee $LOGROTATE_CONFIG > /dev/null << 'EOF'
/var/log/litemaas-key-cleanup.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 0644 root root
}
EOF
else
    # Running from workstation - use SSH
    ssh bastion "sudo tee $LOGROTATE_CONFIG > /dev/null" << 'EOF'
/var/log/litemaas-key-cleanup.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 0644 root root
}
EOF
fi

echo "✓ Log rotation configured"
echo ""

echo "========================================="
echo "Setup Complete!"
echo "========================================="
echo ""
echo "Cronjob details:"
echo "  Schedule: Daily at 2 AM"
echo "  Script: /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh"
echo "  Namespace: $NAMESPACE"
echo "  Cleanup Policy:"
echo "    - Expired keys (expires < current time)"
echo "    - Keys older than 30 days (created_at > 30 days ago)"
echo "  Log file: /var/log/litemaas-key-cleanup.log"
echo ""

if [ "$ON_BASTION" = true ]; then
    echo "Test the script manually:"
    echo "  sudo /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh"
    echo ""
    echo "Verify cronjob is scheduled:"
    echo "  sudo crontab -l | grep cleanup-litemaas-keys"
    echo ""
    echo "View logs:"
    echo "  sudo tail -f /var/log/litemaas-key-cleanup.log"
    echo ""
    echo "Test cronjob will run (dry-run):"
    echo "  sudo run-parts --test /etc/cron.daily"
    echo ""
    echo "Remove cronjob:"
    echo "  sudo crontab -l | grep -v cleanup-litemaas-keys-${NAMESPACE}.sh | sudo crontab -"
    echo "  sudo rm /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh"
else
    echo "Test the script manually:"
    echo "  ssh bastion 'sudo /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh'"
    echo ""
    echo "Verify cronjob is scheduled:"
    echo "  ssh bastion 'sudo crontab -l | grep cleanup-litemaas-keys'"
    echo ""
    echo "View logs:"
    echo "  ssh bastion 'sudo tail -f /var/log/litemaas-key-cleanup.log'"
    echo ""
    echo "Test cronjob will run (dry-run):"
    echo "  ssh bastion 'sudo run-parts --test /etc/cron.daily'"
    echo ""
    echo "Remove cronjob:"
    echo "  ssh bastion 'sudo crontab -l | grep -v cleanup-litemaas-keys-${NAMESPACE}.sh | sudo crontab -'"
    echo "  ssh bastion 'sudo rm /usr/local/bin/cleanup-litemaas-keys-${NAMESPACE}.sh'"
fi
echo ""
